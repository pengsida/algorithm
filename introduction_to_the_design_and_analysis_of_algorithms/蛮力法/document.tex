% !TeX spellcheck = en_US
%% 字体：方正静蕾简体
%%		 方正粗宋
\documentclass[a4paper,left=2.5cm,right=2.5cm,11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{fontspec}
\usepackage{cite}
\usepackage{xeCJK}
\usepackage{indentfirst}
\usepackage{titlesec}
\usepackage{longtable}
\usepackage{graphicx}
\usepackage{float}
\usepackage{rotating}
\usepackage{subfigure}
\usepackage{tabu}
\usepackage{amsmath}
\usepackage{setspace}
\usepackage{amsfonts}
\usepackage{appendix}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\setcounter{secnumdepth}{4}
\usepackage{mhchem}
\usepackage{multirow}
\usepackage{extarrows}
\usepackage{hyperref}
\titleformat*{\section}{\LARGE}
\renewcommand\refname{参考文献}
\renewcommand{\abstractname}{\sihao \cjkfzcs 摘{  }要}
%\titleformat{\chapter}{\centering\bfseries\huge\wryh}{}{0.7em}{}{}
%\titleformat{\section}{\LARGE\bf}{\thesection}{1em}{}{}
\titleformat{\subsection}{\Large\bfseries}{\thesubsection}{1em}{}{}
\titleformat{\subsubsection}{\large\bfseries}{\thesubsubsection}{1em}{}{}
\renewcommand{\contentsname}{{\cjkfzcs \centerline{目{  } 录}}}
\setCJKfamilyfont{cjkhwxk}{STXingkai}
\setCJKfamilyfont{cjkfzcs}{STSongti-SC-Regular}
% \setCJKfamilyfont{cjkhwxk}{华文行楷}
% \setCJKfamilyfont{cjkfzcs}{方正粗宋简体}
\newcommand*{\cjkfzcs}{\CJKfamily{cjkfzcs}}
\newcommand*{\cjkhwxk}{\CJKfamily{cjkhwxk}}
\newfontfamily\wryh{Microsoft YaHei}
\newfontfamily\hwzs{STZhongsong}
\newfontfamily\hwst{STSong}
\newfontfamily\hwfs{STFangsong}
\newfontfamily\jljt{MicrosoftYaHei}
\newfontfamily\hwxk{STXingkai}
% \newfontfamily\hwzs{华文中宋}
% \newfontfamily\hwst{华文宋体}
% \newfontfamily\hwfs{华文仿宋}
% \newfontfamily\jljt{方正静蕾简体}
% \newfontfamily\hwxk{华文行楷}
\newcommand{\verylarge}{\fontsize{60pt}{\baselineskip}\selectfont}  
\newcommand{\chuhao}{\fontsize{44.9pt}{\baselineskip}\selectfont}  
\newcommand{\xiaochu}{\fontsize{38.5pt}{\baselineskip}\selectfont}  
\newcommand{\yihao}{\fontsize{27.8pt}{\baselineskip}\selectfont}  
\newcommand{\xiaoyi}{\fontsize{25.7pt}{\baselineskip}\selectfont}  
\newcommand{\erhao}{\fontsize{23.5pt}{\baselineskip}\selectfont}  
\newcommand{\xiaoerhao}{\fontsize{19.3pt}{\baselineskip}\selectfont} 
\newcommand{\sihao}{\fontsize{14pt}{\baselineskip}\selectfont}      % 字号设置  
\newcommand{\xiaosihao}{\fontsize{12pt}{\baselineskip}\selectfont}  % 字号设置  
\newcommand{\wuhao}{\fontsize{10.5pt}{\baselineskip}\selectfont}    % 字号设置  
\newcommand{\xiaowuhao}{\fontsize{9pt}{\baselineskip}\selectfont}   % 字号设置  
\newcommand{\liuhao}{\fontsize{7.875pt}{\baselineskip}\selectfont}  % 字号设置  
\newcommand{\qihao}{\fontsize{5.25pt}{\baselineskip}\selectfont}    % 字号设置 

\usepackage{diagbox}
\usepackage{multirow}
\boldmath
\XeTeXlinebreaklocale "zh"
\XeTeXlinebreakskip = 0pt plus 1pt minus 0.1pt
\definecolor{cred}{rgb}{0.8,0.8,0.8}
\definecolor{cgreen}{rgb}{0,0.3,0}
\definecolor{cpurple}{rgb}{0.5,0,0.35}
\definecolor{cdocblue}{rgb}{0,0,0.3}
\definecolor{cdark}{rgb}{0.95,1.0,1.0}
\lstset{
	language=C,
	numbers=left,
	numberstyle=\tiny\color{black},
	showspaces=false,
	showstringspaces=false,
	basicstyle=\scriptsize,
	keywordstyle=\color{purple},
	commentstyle=\itshape\color{cgreen},
	stringstyle=\color{blue},
	frame=lines,
	% escapeinside=``,
	extendedchars=true, 
	xleftmargin=1em,
	xrightmargin=1em, 
	backgroundcolor=\color{cred},
	aboveskip=1em,
	breaklines=true,
	tabsize=4
} 

\newfontfamily{\consolas}{Consolas}
\newfontfamily{\monaco}{Monaco}
\setmonofont[Mapping={}]{Consolas}	%英文引号之类的正常显示，相当于设置英文字体
\setsansfont{Consolas} %设置英文字体 Monaco, Consolas,  Fantasque Sans Mono
\setmainfont{Times New Roman}

\setCJKmainfont{华文中宋}


\newcommand{\fic}[1]{\begin{figure}[H]
		\center
		\includegraphics[width=0.8\textwidth]{#1}
	\end{figure}}
	
\newcommand{\sizedfic}[2]{\begin{figure}[H]
		\center
		\includegraphics[width=#1\textwidth]{#2}
	\end{figure}}

\newcommand{\codefile}[1]{\lstinputlisting{#1}}

% 改变段间隔
\setlength{\parskip}{0.2em}
\linespread{1.1}

\usepackage{lastpage}
\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{\space \qquad \space}
\chead{第三章 蛮力法 \qquad}
\rhead{\qquad\thepage/\pageref{LastPage}}
\begin{document}

\tableofcontents

\clearpage

\section{选择排序}
	算法过程：对列表做第i遍扫描的时候，该算法在最后n-i个元素中寻找最小元素，然后拿它和$A_i$交换。\par

	代码实现如下：
	\begin{lstlisting}
	void select_sort(int *A, int len)
	{
		int min;
		int i;
		int j;
		int temp;
		for(i = 0; i < len-1; ++i)
		{
			min = i;
			for(j = i + 1; j < len; ++j)
			{
				if(A[j] < A[min])
					min = j;
			}
			temp = A[min];
			A[min] = A[i];
			A[i] = temp;
		}
	}
	\end{lstlisting}

	算法分析：
	\begin{itemize}
		\item 该算法的基本操作是键值比较A[i]<A[min]。该比较执行次数为$C(n)=\sum_{i=0}{n-2}(n-1-i)$。
		\item 键的交换次数仅为$\Theta(n)$。
		\item 选择排序最坏情况和平均情况的复杂度为$\Theta(n^2)$。
	\end{itemize}

\section{冒泡排序}
	算法思路：从第一个元素开始，比较列表中相邻元素，如果它们是逆序的就交换它们的位置。重复这个过程n-1遍，这个列表就排好序了。

	实现代码如下：
	\begin{lstlisting}
	void bubble_sort(int *A, int len)
	{
		int i, j;
		int temp;
		for(i = 0; i < len; ++i)
		{
			for(j = 0; j < len-i-1; ++j)
			{
				if(A[j+1] < A[j])
				{
					temp = A[j];
					A[j] = A[j+1];
					A[j+1] = temp;
				}
			}
		}
	}
	\end{lstlisting}

	算法分析：
	\begin{itemize}
		\item 冒泡排序的键值比较次数为$\frac{(n-1)n}{2} \in \Theta(n^2)$。
		\item 冒泡排序的最坏情况和平均情况的复杂度为$\Theta(n^2)$。
	\end{itemize}

\section{顺序查找}
	查找问题就是在给定的集合中找一个给定的值。\par
	算法思路：将给定序列中的连续元素和给定的查找健作比较，直到遇到一个匹配的元素。\par
	算法实现的小技巧：将查找键添加到列表的末尾，那么查找一定会成功，所以就不必在算法的每次循环时都检查是否到达了表的末尾。

	代码实现：
	\begin{lstlisting}
	int sequential_search(int *A, int len, int key)
	{
		A[len] = key;
		int i = 0;
		while(A[i] != key)
			++i;
		if(i < n)
			return i;
		else
			return -1;
	}
	\end{lstlisting}

	算法分析：顺序查找是线性算法，时间复杂度为$\Theta(n)$。

\section{蛮力字符串匹配}
	字符串匹配问题：给定一个n个字符组成的串，称为文本。给定一个m个字符的串，称为模式。\par
	算法思路：将模式对准文本的前m个字符，然后从左到右匹配每一对相应的字符，直到m个字符全部匹配。
	如果遇到不匹配的字符，将模式向右移一位，然后从模式的第一个字符开始匹配。\par
	算法实现：
	\begin{lstlisting}
	void brute_force_string_match(int *Text, int *pattern, int n, int m)
	{
		int i,j;
		for(i = 0; i < n-m; ++i)
		{
			j = 0;
			while((j < m) && (P[j] == Text[i+j]))
				++j;
			if(j == m)
				return i;
		}
		return -1;
	}
	\end{lstlisting}

	算法分析：
	\begin{itemize}
		\item 最坏的情况下，算法复杂度为$\Theta(nm)$。
		\item 算法的平均时间复杂度为$\Theta(n+m)=\Theta(n)$。
	\end{itemize}

\section{最近对问题}
	最近对问题：找出一个包含n个点的集合中距离最近的两个点。\par
	算法思路：分别计算每一对点之间的距离，然后找出距离最小的那一对。为了不对同一对点计算两次距离，我们只考虑i<j的那些对($P_iP_j$)。\par
	算法实现：
	\begin{lstlisting}
	struct Point
	{
		int x;
		int y;
	};
	typedef struct Point Point;
	int* brute_force_closest_points(Point *P, int n)
	{
		int x1, x2;
		int y1, y2;
		int i, j;
		int d;
		int dmin = INT32_MAX;
		int index[2];
		for(i = 0; i < n; ++i)
		{
			x1 = P[i].x;
			y1 = P[i].y;
			for(j = i+1; j < n; ++j)
			{
				x2 = P[j].x;
				y2 = P[j].y;
				d = sqrt((x1 - x2)^2 + (y1 - y2)^2);
				if(d < dmin)
				{
					dmin = d;
					index[0] = i;
					index[1] = j;
				}
			}
		}

		if(dmin == INT32_MAX)
			return NULL;
		return index;
	}
	\end{lstlisting}

	算法分析：
	\begin{itemize}
		\item 该算法的基本操作是计算两个点的欧几里得距离。该操作中的平方根计算在计算机中只能近似求解，而且对于计算机而言不是一件轻松的工作。
		所以应该避免求平方根。
		\item 基本操作的执行次数为$\Theta(n^2)$。
	\end{itemize}

\section{凸包问题}
	凸集合的定义：对于平面上的一个点集合，如果以集合中任意两点P和Q为端点的线段都属于该集合，那么这个集合就是凸集合。\par
	凸包的定义：对于平面上n个点的集合，它的凸包就是包含所有这些点的最小凸多边形。\par
	凸包问题：为平面上n个点的集合构造凸包。\par
	极点的定义：将最小凸多边形的顶点称为极点。\par
	算法思路：对于一个n个点集合中的两个点$P_i$和$P_j$，这两个点连成一条直线l，当且仅当该集合中的其他点都位于这条直线l的同一边时，
	l是该集合凸包边界的一部分。对每一对点都做一遍检验之后，满足条件的线段就构成了该凸包的边界。\par
	算法实现：
	\begin{lstlisting}
	// 两个点连成一条直线，方程为ax+by=c
	// 一条直线把平面分为两个半平面，其中一个半平面上的点都满足ax+by>c，而另一个半平面中的点都满足ax+by<c
	// 为了检验某些点是否位于这条直线的同一边，可以简单地把每个点代入ax+by-c，检验这个表达式的符号是否相同
	struct Point
	{
		double x;
		double y;
	}
	typedef struct Point Point;
	Point* solution(Point* p, int len)
	{
		Point* result = (Point*)malloc(len * sizeof(Point));
		int i,j,z;
		double a,b,c;
		double temp_k,temp_b;
		double x1, x2, x3;
		double y1, y2, y3;
		int flag[2];
		int index = 0;
		for(i = 0; i < len; ++i)
		{
			result[i].x = 0;
			result[i].y = 0;
		}
		for(i = 0; i < len; ++i)
		{
			x1 = p[i].x;
			y1 = p[i].y;
			for(j = i + 1; j < len; ++j)
			{
				flag[0] = 0;
				flag[1] = 0;
				x2 = p[j].x;
				y2 = p[j].y;

				if(x1 == x2)
				{
					b = 0;
					c = 1;
					a = 1/x1;
				}
				else
				{
					temp_k = (y1-y2)/(x1-x2);
					temp_b = y1 - temp_k*x1;
					a = temp_k;
					b = -1;
					c = -temp_b;
				}

				for(z = 0; z < len; ++z)
				{
					if(z != i && z != j)
					{
						x3 = p[z].x;
						y3 = p[z].y;
						
						if(flag[0] == 0 && a*x3 + b*y3 > c)
							flag[0] = 1;
						else if(flag[1] == 0 && a*x3 + b*y3 < c)
							flag[1] = 1;
					}
				}

				if(flag[0] && flag[1])
					continue;
				result[index++] = p[i];
				result[index++] = p[j];
			}
		}
	}
	\end{lstlisting}

	算法分析：时间复杂度为$\mathcal{O}(n^3)$。

\section{穷举查找}
\subsection{旅行商问题}
	旅行商问题：要求找出一条n个给定的城市间的最短路径，这条最短路径的出发城市和终点城市是一样的。
	而且要求我们在回到出发的城市之前，对每个城市都只访问过一次。\par
	算法思路：通过生成n-1个中间城市的组合来得到所有的旅游路线，计算这些线路的长度，然后求得最短的线路。\par
	算法分析：算法时间复杂度为$\Theta((n-1)!)$。

\subsection{背包问题}
	背包问题：给定n个重量为$w_1,w_2, ... w_n$，价值为$v_1,v_2, ... v_n$的物品和一个承重为W的背包，
	求这些物品中一个最有价值的子集。\par
	算法思路：计算出每个子集的总重量，找出所有可行的子集，然后在它们中间找到价值最大的子集。\par
	算法分析：一个n元素集合的子集数量为$2^n$，所以算法的时间复杂度为$\Omega(2^n)$。

\subsection{分配问题}
	分配问题：有n个任务需要分配给n个人执行，一个任务一个人。将第j个任务分配给第i个人的成本为C[i,j]。要求找出总成本最小的分配方案。\par
	算法思路：生成整数1,2,...,n的全部排列，然后把成本矩阵中的相应元素相加来求得每种分配方案的总成本，最后选出其中具有最小和的方案。\par
	算法分析：算法时间复杂度为$\Theta(n!)$。

\end{document}
